# **4.** #  

## 4(a) ##  

[4(a)code](https://github.com/Noircoda/algorithm_final/blob/main/4/max_length.py)
要找到黃金的最大長度，使用動態規劃來考慮所有可能的配方組合及其使用順序。
給定的配方：
- 配方1: (5, 3, 2) 
- 配方2: (20, 33, 1)
- 配方3: (30, 115, 1)  

定義兩個大小為n+1的陣列`A`和`B`，用於存儲每個階段的**最大黃金長度**。
`A[i]`表示僅考慮前i個配方時的最大黃金長度。`B[i]`表示考慮前i個配方並在第一輪使用第i個配方時的最大黃金長度。

現在，對於每個i從1到n，使用以下遞迴關係計算A[i]和B[i]的值：  
A[i] = max(A[i - 1], B[i - 1])（當前輪中未使用配方）  
B[i] = max(A[i - 1] * a[i] - b[i], B[i - 1] * a[i])（當前輪中使用第i個配方）  
通過按排序順序考慮配方，確保在每個階段始終有最大長度。 

對於 i = **1**：A[1] = max(A[0], B[0]) = max(0, 0) = 0 B[1] = max(A[0] + 5 - 3, B[0] + 5) = max(0 + 2, 0 + 5) = 5  
對於 i = **2**：A[2] = max(A[1], B[1]) = max(0, 5) = 5 B[2] = max(A[1] + 20 - 33, B[1] + 20) = max(0 - 13, 5 + 20) = 25  
對於 i = **3**：A[3] = max(A[2], B[2]) = max(5, 25) = 25 B[3] = max(A[2] + 30 - 115, B[2] + 30) = max(5 - 85, 25 + 30) = 55  
對於 i = **4**：A[4] = max(A[3], B[3]) = max(25, 55) = 55 B[4] = max(A[3] + 0 - 0, B[3] + 0) = max(25, 55) = 55
黃金的最大長度由max(A[n], B[n])給出，即max(A[4], B[4]) = max(55, 55) = 55。  
### **因此，黃金的最大長度是55。** ###
********************************  
## 4(b) ##  
### **A(i, j)**  ###  
- 如果 j > 0，表示第 i 個配方生效，根據以下兩種情況中的最大長度來獲取最大長度：
  1. 不使用第 i 個配方的前一輪的最大長度 (A(i-1, j))
  2. 在前一輪的最大長度基礎上使用第 i 個配方 (B(i-1, j))。

- 如果 j = 0，表示第 i 個配方不生效，將最大長度設置為 -∞，因為無法達到有效狀態。
### **B(i, j)**  ###  
- 如果 j > 0，根據以下兩種情況中的最大長度來考慮：一是使用第 i 個配方開始新的效果 (A(i-1, j-1) + a[i])，二是在前一輪的效果基礎上繼續效果 (B(i-1, j-1) + a[i] - b[i])。

- 如果 j = 0，將最大長度設置為 -∞，因為無法達到有效狀態。

## So
A(i, j) 和 B(i, j) 的遞迴公式可以定義如下：  
- **A(i, j) = max(A(i-1, j), B(i-1, j)) if j > 0 = -∞ otherwise (if it is not possible)**  

- **B(i, j) = max(A(i-1, j-1) + a[i], B(i-1, j-1) + a[i] - b[i]) if j > 0 = -∞ otherwise (if it is not possible)**  

****************************************************************
[回主頁](https://github.com/Noircoda/algorithm_final/blob/82912cf601b3bac25ea72d4023940b8c1a658697)
